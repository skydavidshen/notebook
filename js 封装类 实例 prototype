=================================== example 1 ===================================

/*封装主要用意在于将实现细节隐藏，提供给客户端的只是定义良好的接口，在js中的封装同其它语言中的封装并无差异，
最为简单的封装就是通过function 函数初始化类。*/

function CreatePerson(name,sex,birthday)  
{  
  this.name = name;
  this.sex = sex;
  this.birthday = birthday;
  
  this.showMe = function(){
	  alert("my name is "+this.name+" \n sex is :"+this.sex+"\n birthday is:"+this.birthday);
  }
}  

//js中函数本身就是类，我们可以通过Shape函数的prototype属性为该类添加方法,如下所示

CreatePerson.prototype ={
	sayHi:function(){
		alert("hi , my name is "+this.name);
	},
	walk:function(){
		alert(this.name+" is walking now");
	}
}

//那么我们多创建几个人的话，就可以  
var person1 = new CreatePerson('zs','boy','2001-02-03');  
var person2 = new CreatePerson('ls','boy','2001-02-04');  
person1.showMe();

person1.walk();
person2.sayHi(); 

=================================== example 2 ===================================

function Shape(){
	this.init = function(param1,param2){
	 this.param1 = param1;
	 this.param2 = param2;
	}
}

Shape.prototype = {
    method1:function(){alert(this.param1)},
    method2:function(){alert(this.param2)}
}

var shape = new Shape();
shape.init('method1','method2');
shape.method1();
shape.method2();

// 在js中并无继承机制，但可以通过将prototype中保存的变量逐一复制也可实现类似java语言中的继承，如下所示：
Object.extend = function(destination, source) {
      // 值得注意的是：Shape类的 param1，param2 这两个属性也被copy到Square类中去了
      for (var property in source){
        destination[property] = source[property];
      }  
      return destination;
};

function Square(){
   /*code here */
}
   
Square.prototype = Object.extend(new Shape(),{method3:function(){alert('square')}});

// 值得注意的是：Shape类的 param1，param2 这两个属性也被copy到Square类中去了
var square = new Square();
square.init('square method1','square method2');
square.method1();
square.method2();
square.method3();

=================================== example 3 ===================================

function DemoA() {
  this.name = "DemoA";
}
function DemoB() { }

//子类.prototype = new 父类;//注意：父类后不能传参数
DemoB.prototype = new DemoA(); //DemoB继承了DemoA
var b = new DemoB();
alert(b.name);

=================================== example 4  the end ===================================

function C(name,sex){
	this.name = name;
	this.sex = sex;
	//虽然这样写是可以的,但是方法不应该写在构造函数里面，他是公用的，所以，更好的解决办法采用prototype原型方式
	/*
	this.showMe = function(){
		alert("my name is : "+this.name+" and my sex is : "+this.sex);
	}
	*/
}

C.prototype = {
	look:function(){
		alert(this.name+" is looking tv");
	},
	play:function(){
		alert(this.name+" is playing");
	},
	showMe:function(){
		alert("my name is : "+this.name+" and my sex is : "+this.sex);	
	}
};

function D(name,sex){
	C.call(this,name,sex);
} 

/*

call([thisObj[,arg1[, arg2[, [,.argN]]]]])

参数:
thisObj 可选项。将被用作当前对象的对象。
arg1, arg2, , argN 可选项。将被传递方法参数序列。

说明: call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指
定的新对象。

eg: C.call(this,name,sex,age,job);
*/

D.prototype = new C();

D.prototype.play = function(){
	alert(this.name + " is play game");
}

/*
// 下面这种写法 会覆盖掉之前 从C类中继承的方法属性  因为  D.prototype = { code } 这个相当于重新赋值方法了
D.prototype = {
	play:function(){
		alert(this.name + " is play game");
	}	
}
*/

var d = new D("dog","man");
d.look();
d.showMe();
d.play();
